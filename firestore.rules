rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Función helper: Verifica si el usuario está autenticado
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Función helper: Verifica si el usuario es el propietario
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Función helper: Verifica si el email está verificado (opcional, para reglas más estrictas)
    function isEmailVerified() {
      return request.auth.token.email_verified == true;
    }
    
    // Reglas para la colección 'users'
    match /users/{userId} {
      // LEER: Cualquier usuario autenticado puede leer su propio documento
      // También permitir lectura desde el backend (sin auth) para operaciones del servidor
      allow read: if isAuthenticated() || request.auth == null;
      
      // CREAR: Permitir creación si el documento no existe (primera vez desde el backend)
      // El backend usa Client SDK sin contexto de auth durante el registro
      // También permitir si el usuario está autenticado y es el dueño
      allow create: if !exists(/databases/$(database)/documents/users/$(userId)) ||
                       (isAuthenticated() && 
                        isOwner(userId) &&
                        request.resource.data.uid == userId &&
                        request.resource.data.shareCode is string &&
                        request.resource.data.shareCode.size() == 6 &&
                        request.resource.data.familyMembers is list);
      
      // ACTUALIZAR: Permitir si el usuario es el dueño
      // También permitir actualizar familyMembers de otros usuarios para sincronización bidireccional
      // El backend puede actualizar usando el token del usuario en el header
      allow update: if isAuthenticated() && (
                       // El usuario puede actualizar su propio documento completamente
                       (isOwner(userId) &&
                        resource.data.uid == userId &&
                        request.resource.data.uid == userId) ||
                       // O puede actualizar solo el campo familyMembers de otros usuarios (para sincronización)
                       (!isOwner(userId) &&
                        // Asegurar que los campos críticos no cambien
                        request.resource.data.uid == resource.data.uid &&
                        request.resource.data.shareCode == resource.data.shareCode &&
                        request.resource.data.email == resource.data.email &&
                        // Permitir cambios en familyMembers y updatedAt
                        request.resource.data.familyMembers is list)
                     ) ||
                     // Permitir actualizar emailVerified desde el backend
                     request.auth == null;
      
      // ELIMINAR: Solo si está autenticado y es el propietario
      allow delete: if isAuthenticated() && 
                       isOwner(userId);
    }
    
    // Reglas para la colección 'familyGroups'
    match /familyGroups/{groupId} {
      // LEER: 
      // - Si está autenticado y es miembro del grupo, O
      // - Si está autenticado (para buscar grupos por shareCode), O
      // - Si no hay auth (backend - el backend valida tokens antes)
      allow read: if (isAuthenticated() && 
                     request.auth.uid in resource.data.members) ||
                     isAuthenticated() ||
                     request.auth == null;
      
      // CREAR: Solo si está autenticado y se incluye a sí mismo como miembro
      allow create: if isAuthenticated() && 
                       request.resource.data.createdBy == request.auth.uid &&
                       request.auth.uid in request.resource.data.members &&
                       request.resource.data.name is string &&
                       request.resource.data.name.size() >= 3 &&
                       request.resource.data.name.size() <= 50 &&
                       request.resource.data.shareCode is string &&
                       request.resource.data.shareCode.size() == 6 &&
                       request.resource.data.members is list;
      
      // ACTUALIZAR: 
      // - Si está autenticado y es miembro del grupo, O
      // - Si está autenticado y se está agregando a sí mismo, O
      // - Si no hay auth (backend - el backend valida tokens antes)
      allow update: if (isAuthenticated() && 
                       request.auth.uid in resource.data.members) ||
                       (isAuthenticated() && 
                        !(request.auth.uid in resource.data.members) &&
                        request.auth.uid in request.resource.data.members) ||
                       request.auth == null;
      
      // ELIMINAR: Solo si está autenticado y es el creador o un admin
      allow delete: if isAuthenticated() && 
                       (resource.data.createdBy == request.auth.uid ||
                        (resource.data.roles[request.auth.uid] == 'admin'));
    }
    
    // Reglas para la colección 'groupNotifications'
    match /groupNotifications/{notificationId} {
      // LEER: Solo el usuario dueño de la notificación
      // También permitir lectura desde el backend (sin auth) para consultas del servidor
      // El backend valida el token en el middleware antes de hacer las consultas
      allow read: if (isAuthenticated() && 
                     isOwner(resource.data.userId)) ||
                     request.auth == null;
      
      // CREAR: Solo desde el backend (sin auth) o si el userId coincide
      allow create: if request.auth == null ||
                       (isAuthenticated() && 
                        request.resource.data.userId is string);
      
      // ACTUALIZAR: Solo el usuario dueño puede marcar como leída
      allow update: if isAuthenticated() && 
                       isOwner(resource.data.userId) &&
                       // Solo permitir cambiar el campo 'read'
                       request.resource.data.userId == resource.data.userId &&
                       request.resource.data.groupId == resource.data.groupId &&
                       request.resource.data.type == resource.data.type &&
                       request.resource.data.message == resource.data.message;
      
      // ELIMINAR: Solo el usuario dueño
      allow delete: if isAuthenticated() && 
                       isOwner(resource.data.userId);
    }
    
    // Reglas para la colección 'tasks'
    match /tasks/{taskId} {
      // LEER: Si está autenticado y es el creador O el asignado de la tarea
      // También permitir lectura si no hay auth (para consultas desde el backend)
      // El backend valida el token en el middleware antes de hacer las consultas
      allow read: if isAuthenticated() && 
                     (isOwner(resource.data.createdBy) || 
                      request.auth.uid == resource.data.assignedTo) ||
                     request.auth == null;
      
      // CREAR: Solo si está autenticado y el createdBy es el usuario actual
      // Descripción es opcional (puede ser string vacío o null)
      // groupId es opcional (puede ser string, null, o no existir)
      allow create: if isAuthenticated() && 
                       isOwner(request.resource.data.createdBy) &&
                       request.resource.data.title is string &&
                       request.resource.data.title.size() >= 3 &&
                       request.resource.data.title.size() <= 100 &&
                       (request.resource.data.description is string || 
                        request.resource.data.description == null) &&
                       request.resource.data.assignedTo is string &&
                       request.resource.data.dueDate is string &&
                       request.resource.data.priority in ['Alta', 'Media', 'Baja'] &&
                       request.resource.data.isCompleted is bool &&
                       (!('groupId' in request.resource.data) || 
                        request.resource.data.groupId is string || 
                        request.resource.data.groupId == null);
      
      // ACTUALIZAR: Si está autenticado y es el creador O el asignado (para marcar como completada)
      allow update: if isAuthenticated() && 
                       (isOwner(resource.data.createdBy) || 
                        request.auth.uid == resource.data.assignedTo);
      
      // ELIMINAR: Solo si está autenticado y es el creador
      allow delete: if isAuthenticated() && 
                       isOwner(resource.data.createdBy);
    }
  }
}
